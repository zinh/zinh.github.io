---
layout: post
title: "Compiler, linker and loader in Linux"
date: 2019-12-06 00:00:01
summary: my explanation of gcc(or clang) compiler, linker and loader
description: 
categories: programming
---

Let's have a simple program in C such as:

~~~ ruby
// main.c
int main() {
  return 0;
}
~~~

which does nothing except return 0 to caller;

We compile it using gcc and get an executable.

~~~
gcc main.c -o main
~~~

now, there are lots of thing happen while running this command,

First, a preprocessor will preprocess this c source to expand any `#include`, `#define` statemenets. It's result is just another C source.
After that, the compiler will convert this c source into assembly.

We can single out this step by using the argument:

~~~
gcc -S main.c
~~~

which will emit a `main.S` assembly source code.

Then we will need an assembler to actually convert this `.S` file into machine code(i.e binary format)

this step can be run by passing `-c` option to gcc

~~~
gcc -c main.s
~~~

or we can use another tool call GNU Assembler(as), one of the two main tools of GNU's binutilities. The other one is `ld` which is used in liking step.

TODO: fix parameter of as
~~~
as main.s
~~~

The result of assembler step is an object file that is readly to be linked into an executable.

Scanning the assembly source code, we see it defines various sections(eg: .text, .data, ...). These sections vary depends on the target architecture and executable format but let's just stick to Linux and it's default ELF format.

In ELF format, assembly code is devided into 3 main sections
- `.text`: contain the code that actually will be run on CPU
- `.data`: contain constant value, initialized variables.
- `.bss`: contains uninitialize variables.

Actually, ELF allows abitrary kinds of sections but the aforementioned are the main one.

If we have only one source and it doesn't use any other library(which usually not the case), the compilation chain can just convert this `.o` file into `ELF` format.
But if there a many source file and we need to assemble these source file into one, that's the job of linker(the `ld` command).

The linker will read each of its input's sections, merged and relocated them into approriated position in the executable.
